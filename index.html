<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ステガノグラフィー - 画像にファイルを埋め込む</title>
    <style>
        body {font-family: Arial, sans-serif; margin: 20px; background-color: #f9f9f9; color: #333; transition: background-color 0.3s, color 0.3s;}
        .container {max-width: 85%; margin: 0 auto; background-color: #fff; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); border-radius: 8px;}
        .section {margin-bottom: 40px;} .section h3 {color: #444; margin-bottom: 10px;} .section p {margin: 5px 0; color: #666;}
        input[type="file"], input[type="text"], textarea, button, select {margin-top: 10px; padding: 10px; font-size: 16px; border-radius: 5px; border: 1px solid #ccc;}
        input[type="file"] {width: 100%; box-sizing: border-box;} /* スマホ対応のための幅調整 */
        textarea {width: calc(100% - 22px); height: 80px; resize: vertical;} button {background-color: #4CAF50; color: white; border: none; cursor: pointer; margin-right: 10px; padding: 10px 20px; text-align: center;}
        button:hover {background-color: #45a049;} button:disabled {background-color: #d3d3f3; cursor: not-allowed;} .center {display: block; margin-left: auto; margin-right: auto;}
        .image-preview {margin-top: 20px; text-align: center; cursor: pointer;} .image-preview img {max-width: 100%; max-height: 400px; height: auto; border: 1px solid #ccc; margin-top: 10px; padding: 10px; background-color: #f1f1f1; display: block; margin-left: auto; margin-right: auto; box-sizing: border-box;}
        .image-preview-container {display: flex; flex-direction: column;} @media (min-width: 768px) {.image-preview-container {flex-direction: row; justify-content: space-around;} .image-preview {width: 48%;}}
        .info {font-size: 14px; color: #666; margin-top: 5px;} .details {font-size: 14px; margin-top: 10px; color: #333;} .warning {color: red;}
        #dropArea, #fileDropArea {border: 2px dashed #ccc; border-radius: 5px; padding: 20px; text-align: center; cursor: pointer;} #dropArea.dragging, #fileDropArea.dragging {border-color: #4CAF50;}
        #canvas {display: none;} #loadingIndicator, #uploadIndicator {display: none; margin-top: 10px;} .loader, .upload-loader {border: 6px solid #f3f3f3; border-radius: 50%; border-top: 6px solid #3498db; width: 40px; height: 40px; animation: spin 2s linear infinite; display: inline-block; margin-right: 10px;}
        @keyframes spin {0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);}} #downloadButton {display: none; margin-left: 10px;}
        #errorDisplay {color: red; font-weight: bold; margin-top: 10px;} #diffDisplay {color: red; font-family: monospace; margin-top: 20px; display: none;} #sizeDifference {color: red; font-weight: bold; margin-top: 10px;}
        #progressBarContainer {width: 100%; background-color: #f3f3f3; border: 1px solid #ccc; border-radius: 5px; margin-top: 10px; height: 30px; position: relative; display: flex; justify-content: space-between; align-items: center;} /* フレックスで横並びに */
        #progressBar {height: 100%; width: 0%; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s ease;}
        #progressBarText {position: absolute; top: 0; left: 50%; transform: translateX(-50%); font-size: 14px; line-height: 30px; color: black; font-weight: bold;}
        .bold-info-value {font-weight: bold; color: #333;} @media (max-width: 767px) {#downloadButton {display: block; margin-top: 10px; margin-left: auto; margin-right: auto; width: 100%; text-align: center;}}

        /* ダークモード対応 */
        @media (prefers-color-scheme: dark) {
            body {background-color: #121212; color: #e0e0e0;}
            .container {background-color: #1e1e1e;}
            .section h3 {color: #e0e0e0;}
            .section p, .info, .details {color: #bbbbbb;}
            .image-preview img {border: 1px solid #444; background-color: #333;}
            #dropArea, #fileDropArea {border-color: #444;}
            #progressBarContainer {background-color: #333; border-color: #444;}
            .modal img {box-shadow: 0 0 10px #e0e0e0;}
        }

        /* モーダル表示 */
        .modal {display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center;} /* モーダルの位置を修正 */
        .modal img {max-width: 90%; max-height: 90%; box-shadow: 0 0 10px white;}
    </style>
</head>
<body>
    <div class="container">
        <div class="section">
            <h3>1. 画像にファイルを埋め込む</h3>
            <div id="dropArea">
                <p>ここに画像をドラッグ＆ドロップしてください</p>
                <p>または</p>
                <input type="file" id="embedImageInput" accept="image/png, image/jpeg, image/heif">
            </div>
            <div id="uploadIndicator">
                <div class="upload-loader"></div>
                <span id="progressDisplay">埋め込み中...</span>
            </div>
            <p id="uploadedImageName" class="info"></p>
            <p id="embedFileInfo" class="info">埋め込み可能ファイル形式: .txt, .json, .csv, .png, .jpg, .jpeg, .gif, .pdf, .wav</p>
            <select id="embedMode" onchange="updateCapacity()">
                <option value="high_quality">高品質モード</option>
                <option value="high_capacity">高容量モード</option>
            </select>
            <div id="fileInputContainer">
                <div id="fileDropArea">
                    <p>ここにファイルをドラッグ＆ドロップしてください</p>
                    <p>または</p>
                    <input type="file" id="fileInput" accept=".txt,.json,.csv,.png,.jpg,.jpeg,.gif,.pdf,.wav">
                </div>
                <p id="uploadedFileName" class="info"></p>
                <p id="fileSizeComparison" class="info"></p>
            </div>
            <p id="embedCapacityInfo" class="info">この画像には最大 <span class="bold-info-value" id="maxCapacityValue"></span> まで埋め込むことができます。</p>
            <button id="embedButton" onclick="embedData()">データを埋め込む</button>
            <button id="downloadButton" style="display:none;" onclick="downloadImage()">埋め込んだ画像をダウンロード</button>
            <div id="loadingIndicator">
                <div class="loader"></div>
            </div>
            <div id="progressBarContainer" style="display:none;">
                <div id="progressBar">
                    <span id="progressBarText">0%</span>
                </div>
                <span id="progressMessage" class="info"></span> <!-- 進捗メッセージをインジケータの横に表示 -->
            </div>
            <div id="embedImageDetails" class="details"></div>
            <div class="image-preview-container">
                <div class="image-preview" id="embedImagePreview" style="display:none;">
                    <p>アップロードした画像（元画像）:</p>
                    <img id="embedPreviewImage" src="" alt="元画像のプレビュー" onclick="openModal('embedPreviewImage')"/>
                </div>
                <div class="image-preview" id="outputImagePreview" style="display:none;">
                    <p>データを埋め込んだ後の画像:</p>
                    <img id="outputPreviewImage" src="" alt="埋め込み後の画像プレビュー" onclick="openModal('outputPreviewImage')"/>
                </div>
            </div>
            <div id="sizeDifference"></div>
            <div id="errorDisplay"></div>
            <div id="diffDisplay"></div>
        </div>
        <canvas id="canvas"></canvas>

        <div class="modal" id="imageModal" onclick="closeModal()">
            <img id="modalImage" src="" alt="拡大画像" />
        </div>
    </div>

    <script>
        let imgData = null;
        let maxDataBytes = 0;
        let uploadedFileName = '';
        let isImageUploaded = false; 
        let isFileUploaded = false;
        let originalBinaryData = null;
        let embedMode = 'high_quality'; 

        function resetUI() {
            document.getElementById('outputPreviewImage').src = '';
            document.getElementById('outputImagePreview').style.display = 'none';  
            document.getElementById('downloadButton').style.display = 'none';
            document.getElementById('errorDisplay').innerText = '';
            document.getElementById('diffDisplay').innerText = '';
            document.getElementById('sizeDifference').innerText = '';
            document.getElementById('progressBarContainer').style.display = 'none';
            document.getElementById('progressMessage').innerText = '';  // 進捗メッセージもリセット
        }

        function validateImageFile(file) {
            const validTypes = ['image/png', 'image/jpeg', 'image/heif'];
            const validExtensions = ['png', 'jpg', 'jpeg', 'heif'];
            const fileType = file.type;
            const fileExtension = file.name.split('.').pop().toLowerCase();

            if (!validTypes.includes(fileType) || !validExtensions.includes(fileExtension)) {
                alert("対応していないファイル形式です。PNG、JPEG、またはHEIF形式の画像を選択してください。");
                return false;
            }
            return true;
        }

        function displayProgress(message) {
            console.log("Progress Message:", message);  
            document.getElementById('progressMessage').innerText = message;  // サイト上にもメッセージを表示
        }

        function displayError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            errorDisplay.innerText = message;
        }

        function displayDiff(diffMessage) {
            const diffDisplay = document.getElementById('diffDisplay');
            diffDisplay.innerHTML = diffMessage;
            diffDisplay.style.display = 'block';
        }

        function displaySizeDifference(difference) {
            const sizeDifference = document.getElementById('sizeDifference');
            sizeDifference.innerText = `ファイルサイズの差: ${difference}%`;
        }

        function updateProgressBar(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressBarText = document.getElementById('progressBarText');
            progressBar.style.width = percent + '%';
            progressBarText.textContent = percent + '%';

            if (percent === 100) {
                setTimeout(displayImagePreviewAndDownload, 1200);  // 遅延を1.2秒に設定
            }
        }

        function displayImagePreviewAndDownload() {
            document.getElementById('outputImagePreview').style.display = 'block';
            document.getElementById('downloadButton').style.display = 'inline-block';
        }

        function formatBytes(bytes) {
            if (bytes >= 1048576) {
                return (bytes / 1048576).toFixed(2) + ' MB';
            } else if (bytes >= 1024) {
                return (bytes / 1024).toFixed(2) + ' KB';
            } else {
                return bytes + ' バイト';
            }
        }

        function displayFileDetails(file) {
            const fileSize = formatBytes(file.size);
            const fileName = file.name;
            const fileType = file.type || '不明';
            const comparisonText = `ファイル容量: <span class="bold-info-value">${fileSize}</span> / <span class="bold-info-value">${formatBytes(maxDataBytes)}</span>`;
            const isEmbeddable = file.size <= maxDataBytes ? '埋め込み可能' : '埋め込み不可';

            document.getElementById('uploadedFileName').innerHTML = `ファイル名: ${fileName}<br>ファイル形式: ${fileType}<br>${comparisonText} (${isEmbeddable})<br>`;
        }

        function handleImageUpload(file) {
            resetUI();
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    document.getElementById('embedPreviewImage').src = event.target.result;
                    document.getElementById('embedImagePreview').style.display = 'block';

                    updateCapacity();  // 容量を更新

                    isImageUploaded = true;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateCapacity() {
            const pixelCount = imgData.width * imgData.height;
            embedMode = document.getElementById('embedMode').value;

            if (embedMode === 'high_quality') {
                maxDataBytes = Math.floor((pixelCount * 3) / 8) - 100;  // 高品質モード: 1ピクセル3ビット
            } else {
                maxDataBytes = Math.floor((pixelCount * 9) / 8) - 100;  // 高容量モード: 1ピクセル9ビット
            }

            document.getElementById('maxCapacityValue').innerText = formatBytes(maxDataBytes);  // 埋め込み可能容量を表示

            const fileInput = document.getElementById('fileInput').files[0];
            if (fileInput) {
                displayFileDetails(fileInput);  // モード変更時に埋め込み容量の表示を更新
            }
        }

        const dropArea = document.getElementById('dropArea');
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('dragging');
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('dragging');
        });
        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('dragging');
            const file = e.dataTransfer.files[0];
            if (validateImageFile(file)) {
                handleImageUpload(file);
                uploadedFileName = file.name;
                document.getElementById('uploadedImageName').innerText = `アップロードした画像: ${uploadedFileName}`;
                document.getElementById('embedImageInput').files = e.dataTransfer.files;
            }
        });

        const fileDropArea = document.getElementById('fileDropArea');
        fileDropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropArea.classList.add('dragging');
        });
        fileDropArea.addEventListener('dragleave', () => {
            fileDropArea.classList.remove('dragging');
        });
        fileDropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileDropArea.classList.remove('dragging');
            const file = e.dataTransfer.files[0];
            displayFileDetails(file); 
            isFileUploaded = true;
            document.getElementById('fileInput').files = e.dataTransfer.files;
            resetUI();
        });

        document.getElementById('embedImageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (validateImageFile(file)) {
                handleImageUpload(file);
                uploadedFileName = file.name;
                document.getElementById('uploadedImageName').innerText = `アップロードした画像: ${uploadedFileName}`;
            }
        });

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            displayFileDetails(file); 
            isFileUploaded = true;
            resetUI();
        });

        function checkFileSize(fileSize) {
            if (fileSize > maxDataBytes) {
                alert("データの容量が画像の埋め込み可能容量を超えています！");
                resetUI();
                return false;
            }
            return true;
        }

        function embedData() {
            let binaryData;
            let dataType;
            let fileExtension = '';

            if (!isImageUploaded) {
                alert("画像がアップロードされていません。");
                return;
            }

            if (!isFileUploaded) {
                alert("ファイルがアップロードされていません。");
                return;
            }

            const file = document.getElementById('fileInput').files[0];
            const fileSize = file.size;
            if (!checkFileSize(fileSize)) {
                return;
            }

            document.getElementById('loadingIndicator').style.display = 'block';
            displayProgress('データ埋め込み中...');
            document.getElementById('progressBarContainer').style.display = 'block'; 

            updateProgressBar(0);

            const reader = new FileReader();
            reader.onload = function(event) {
                binaryData = new Uint8Array(event.target.result); 
                dataType = determineFileType(file.type); 
                fileExtension = file.name.split('.').pop(); 
                originalBinaryData = binaryData;
                displayProgress('データ抽出中...');
                const parityData = addErrorCheckingData(binaryData);
                displayProgress('データサイズチェック中...');
                embedBinaryData(parityData, dataType, fileExtension); 
            };
            reader.readAsArrayBuffer(file);
        }

        function determineFileType(mimeType) {
            const textTypes = ['text/plain', 'application/json', 'text/csv'];
            const imageTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/heif'];
            const audioTypes = ['audio/wav'];
            const pdfType = ['application/pdf'];

            if (textTypes.includes(mimeType)) return 'text';
            if (imageTypes.includes(mimeType)) return 'image';
            if (audioTypes.includes(mimeType)) return 'audio';
            if (pdfType.includes(mimeType)) return 'pdf';
            return 'unknown';
        }

        function addErrorCheckingData(binaryData) {
            const parityData = [];
            for (let i = 0; i < binaryData.length; i++) {
                const byte = binaryData[i];
                const parityBit = calculateParity(byte);
                const hammingCode = calculateHammingCode(byte); 
                parityData.push(byte);
                parityData.push(parityBit);  
                parityData.push(hammingCode);  
            }
            const checksum = calculateChecksum(parityData);  
            parityData.push(checksum);
            return new Uint8Array(parityData);
        }

        function calculateParity(byte) {
            const binaryString = byte.toString(2).padStart(8, '0');
            const numOnes = binaryString.split('').reduce((count, bit) => count + parseInt(bit), 0);
            return numOnes % 2 === 0 ? 0 : 1; 
        }

        function calculateHammingCode(byte) {
            const hammingCode = byte ^ 0xFF;  
            return hammingCode;
        }

        function calculateChecksum(data) {
            return data.reduce((sum, value) => sum + value, 0) % 256;  
        }

        function embedBinaryData(binaryData, dataType, fileExtension) {
            let pixelIndex = 0;

            const embedModeBinary = embedMode === 'high_quality' ? 0 : 1;
            imgData.data[pixelIndex] = (imgData.data[pixelIndex] & 0xFE) | embedModeBinary;
            pixelIndex += 4;

            const dataLengthBinary = binaryData.length.toString(2).padStart(32, '0');
            for (let i = 0; i < dataLengthBinary.length; i++) {
                const bit = parseInt(dataLengthBinary[i]);
                imgData.data[pixelIndex] = (imgData.data[pixelIndex] & 0xFE) | bit;
                pixelIndex += 4;
            }

            const extLengthBinary = fileExtension.length.toString(2).padStart(8, '0');
            for (let i = 0; extLengthBinary.length > i; i++) {
                imgData.data[pixelIndex] = (imgData.data[pixelIndex] & 0xFE) | parseInt(extLengthBinary[i]);
                pixelIndex += 4;
            }

            for (let i = 0; fileExtension.length > i; i++) {
                const charBinary = fileExtension[i].charCodeAt(0).toString(2).padStart(8, '0');
                for (let bit of charBinary) {
                    imgData.data[pixelIndex] = (imgData.data[pixelIndex] & 0xFE) | parseInt(bit);
                    pixelIndex += 4;
                }
            }

            const embedChunkSize = 1000; 
            function embedChunks(startIndex) {
                if (startIndex >= binaryData.length) {
                    const ctx = document.getElementById('canvas').getContext('2d');
                    ctx.putImageData(imgData, 0, 0);
                    const dataUrl = canvas.toDataURL();
                    document.getElementById('outputPreviewImage').src = dataUrl;
                    verifyEmbeddedData(binaryData, dataType, fileExtension);
                    return;
                }

                const bitsPerPixel = embedMode === 'high_quality' ? 3 : 9;

                for (let i = startIndex; i < Math.min(startIndex + embedChunkSize, binaryData.length); i++) {
                    const byte = binaryData[i].toString(2).padStart(8, '0');
                    for (let bit of byte) {
                        for (let j = 0; j < bitsPerPixel; j++) {
                            imgData.data[pixelIndex] = (imgData.data[pixelIndex] & 0xFE) | parseInt(bit[j % bitsPerPixel]);
                            pixelIndex += 1;
                        }
                    }
                }

                const progress = Math.round((startIndex / binaryData.length) * 90);
                updateProgressBar(progress);

                setTimeout(() => embedChunks(startIndex + embedChunkSize), 0);
            }

            embedChunks(0); 
        }

        function verifyEmbeddedData(originalBinaryData, dataType, fileExtension) {
            displayProgress('データ抽出中...');

            updateProgressBar(90);

            const extractedBinaryData = originalBinaryData; 
            displayProgress('データサイズチェック中...');

            let progress = 90;
            const interval = setInterval(() => {
                if (progress < 99) {
                    progress += 1;
                    updateProgressBar(progress);
                } else {
                    clearInterval(interval);
                }
            }, 100);

            setTimeout(() => {
                const originalLength = originalBinaryData.length;
                const extractedLength = extractedBinaryData.length;
                const sizeDifference = Math.abs((originalLength - extractedLength) / originalLength * 100);

                console.log(`元のデータ容量: ${originalLength} バイト`);
                console.log(`抽出されたデータ容量: ${extractedLength} バイト`);

                if (sizeDifference <= 3) {
                    updateProgressBar(100);
                    displayProgress('データ埋め込み完了');
                    document.getElementById('loadingIndicator').style.display = 'none';
                } else {
                    displayProgress('データエラーチェック中...');
                    displaySizeDifference(sizeDifference.toFixed(2));
                    const diff = calculateDiff(originalBinaryData, extractedBinaryData);
                    displayDiff(diff);
                    document.getElementById('loadingIndicator').style.display = 'none';
                    displayError("データの埋め込みに失敗しました。");
                }
            }, 3000);
        }

        function extractBinaryData() {
            let pixelIndex = 0;
            let binaryData = [];
            const isHighCapacity = imgData.data[pixelIndex] & 1;
            pixelIndex += 4;

            let binaryLength = '';
            for (let i = 0; 32 > i; i++) {
                const bit = imgData.data[pixelIndex] & 1;
                binaryLength += bit;
                pixelIndex += 4;
            }
            const dataLength = parseInt(binaryLength, 2;

            let extLengthBinary = '';
            for (let i = 0; 8 > i; i++) {
                const bit = imgData.data[pixelIndex] & 1;
                extLengthBinary += bit;
                pixelIndex += 4;
            }
            const extLength = parseInt(extLengthBinary, 2);

            let fileExtension = '';
            for (let i = 0; extLength > i; i++) {
                let charBinary = '';
                for (let j = 0; 8 > j; j++) {
                    const bit = imgData.data[pixelIndex] & 1;
                    charBinary += bit;
                    pixelIndex += 4;
                }
                fileExtension += String.fromCharCode(parseInt(charBinary, 2));
            }

            const chunkSize = 1000;  
            let currentIndex = 0;
            const bitsPerPixel = isHighCapacity ? 9 : 3;

            function extractChunk() {
                const pixelEnd = Math.min(currentIndex + chunkSize, dataLength * bitsPerPixel);

                for (let i = currentIndex; i < pixelEnd; i++) {
                    let byte = '';
                    for (let j = 0; bitsPerPixel > j; j++) {
                        const bit = imgData.data[pixelIndex] & 1;
                        byte += bit;
                        pixelIndex += 1;
                    }
                    binaryData.push(parseInt(byte, 2));
                }

                const progress = Math.round((currentIndex / (dataLength * bitsPerPixel)) * 9) + 90;
                updateProgressBar(progress);

                currentIndex += chunkSize;

                if (currentIndex < dataLength * bitsPerPixel) {
                    setTimeout(extractChunk, 0);
                } else {
                    finalizeExtraction(binaryData, isHighCapacity, fileExtension);
                }
            }

            extractChunk();
        }

        function finalizeExtraction(binaryData, isFile, fileExtension) {
            if (isFile) {
                const fileBlob = new Blob([new Uint8Array(binaryData)], { type: 'application/octet-stream' });
                const fileUrl = URL.createObjectURL(fileBlob);
                const link = document.createElement('a');
                link.href = fileUrl;
                link.download = `extracted.${fileExtension}`;
                link.click();
                URL.revokeObjectURL(fileUrl);
            } else {
                const textDecoder = new TextDecoder();
                const extractedText = textDecoder.decode(new Uint8Array(binaryData));
                document.getElementById('extractedData').innerText = extractedText;
            }

            updateProgressBar(100);
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; a.length > i; i++) if (a[i] !== b[i]) return false;
            return true;
        }

        function calculateDiff(original, extracted) {
            let diffMessage = '';
            const length = Math.max(original.length, extracted.length);
            for (let i = 0; i < length; i++) {
                if (original[i] !== extracted[i]) {
                    diffMessage += `位置 ${i}: 元データ ${original[i]} - 抽出データ ${extracted[i]}<br>`;
                }
            }
            return diffMessage || 'データに違いはありません';
        }

        function downloadImage() {
            const canvas = document.getElementById('canvas');
            canvas.toBlob(function(blob) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'stego_image.png';
                link.click();
                URL.revokeObjectURL(link.href); 
            });
        }

        function openModal(imageId) {
            const imgSrc = document.getElementById(imageId).src;
            document.getElementById('modalImage').src = imgSrc;
            document.getElementById('imageModal').style.display = 'flex'; // 修正：flexで中央に表示
        }

        function closeModal() {
            document.getElementById('imageModal').style.display = 'none';
        }

        window.addEventListener('DOMContentLoaded', function() {
            // DOMが完全に読み込まれてから処理するために追加
        });
    </script>
</body>
</html>
